<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style> body { margin: 0; overflow: hidden; background: #50a03c; touch-action: none; } </style>
</head>
<body>
<script>
let player, bullets = [], enemies = [], deadQueue = [], bossBullets = [], boss;
let imgs = [];
let gameOver = false, score = 0, totalCleaned = 0, TARGET_CLEANED = 15; 
let bins = [];
let currentCarryType = -1, screenShake = 0;
let leftJoy = { active: false, id: -1, x: 0, y: 0, currX: 0, currY: 0 };
let rightJoy = { active: false, id: -1, x: 0, y: 0, currX: 0, currY: 0 };
let joySize = 130;

function preload() {
    imgs[0] = loadImage('怪物1號.png'); 
    imgs[1] = loadImage('怪物二號.png'); 
    imgs[2] = loadImage('怪物三號.png'); 
    imgs[3] = loadImage('怪物四號.png'); 
}

function setup() { 
    createCanvas(windowWidth, windowHeight); 
    player = new Player(); 
    let binLabels = ["塑膠類", "紙類", "玻璃類", "金屬類"];
    let binColors = [color(255, 220, 0), color(255, 50, 50), color(50, 200, 50), color(0, 100, 255)];
    let spacing = width / 4;
    for(let i=0; i<4; i++) {
        bins.push({ x: spacing*i + spacing/2, y: height-75, w: 85, h: 110, type: i, col: binColors[i], label: binLabels[i] });
    }
}

function draw() {
    if (gameOver) {
        background(0, 200); fill(255, 50, 50); textAlign(CENTER); textSize(40);
        text("環境守護失敗！", width/2, height/2);
        textSize(20); fill(255); text("按 F5 或 點擊畫面 重新開始", width/2, height/2 + 50);
        return;
    }
    
    // 畫面震動效果
    if (screenShake > 0) {
        translate(random(-screenShake, screenShake), random(-screenShake, screenShake));
        screenShake *= 0.9;
    }

    background(80, 160, 60); 
    drawGrass();
    handleInput();
    drawFancyBins();

    player.update(); player.display();

    // 怪物生成
    if (totalCleaned < TARGET_CLEANED) {
        if (frameCount % 80 === 0 && enemies.length < 8) enemies.push(new NightMarketMonster());
    } else if (!boss) {
        boss = new StyrofoamTitan();
        enemies = []; 
    }

    if (boss) {
        boss.update(); boss.display();
        if (boss.hp <= 0) {
            noLoop(); background(0, 200); fill(0, 255, 100); textAlign(CENTER); textSize(35);
            text("成功淨化保麗龍泰坦！", width/2, height/2);
        }
    }

    processGameLogic(); 
    drawUI();
    drawJoystick(leftJoy, color(0, 200, 255, 80));
    drawJoystick(rightJoy, color(255, 50, 50, 80));
}

function drawFancyBins() {
    rectMode(CENTER);
    for (let b of bins) {
        push();
        translate(b.x, b.y);
        if (currentCarryType === b.type) {
            noStroke(); fill(255, 255, 255, 50 + sin(frameCount * 0.1) * 30);
            rect(0, 0, b.w + 15, b.h + 15, 12);
        }
        fill(0, 50); rect(5, 5, b.w, b.h, 10);
        fill(b.col); stroke(255); strokeWeight(2); rect(0, 0, b.w, b.h, 10);
        fill(red(b.col)*0.8, green(b.col)*0.8, blue(b.col)*0.8);
        rect(0, -b.h/2 + 5, b.w + 10, 15, 5);
        drawRecycleSymbol(0, 5, 25);
        fill(255); noStroke(); textAlign(CENTER); textSize(14); textStyle(BOLD);
        text(b.label, 0, b.h/2 + 25);
        pop();
    }
}

function drawRecycleSymbol(x, y, size) {
    push(); translate(x, y); stroke(255); strokeWeight(2); noFill();
    for (let i = 0; i < 3; i++) {
        push(); rotate(TWO_PI / 3 * i);
        beginShape(); vertex(-size/2, size/2.5); vertex(size/2, size/2.5); vertex(size/4, size/6); endShape();
        push(); translate(size/2, size/2.5); rotate(PI/4); line(0, 0, -6, 0); line(0, 0, 0, -6); pop();
        pop();
    }
    pop();
}

function drawGrass() {
    stroke(60, 140, 50); strokeWeight(2);
    for(let i=50; i<width; i+=150) {
        for(let j=50; j<height; j+=150) {
            line(i, j, i-5, j+10); line(i, j, i+5, j+10);
        }
    }
}

class Player {
    constructor() { this.x = width/2; this.y = height*0.5; this.vx = 0; this.vy = 0; this.hp = 100; }
    update() {
        this.vx *= 0.85; this.vy *= 0.85; this.x += this.vx; this.y += this.vy;
        this.x = constrain(this.x, 20, width-20); this.y = constrain(this.y, 20, height-180);
    }
    display() {
        push(); translate(this.x, this.y);
        if (this.vx < -0.1) scale(-1, 1);
        noStroke();
        let earShake = sin(frameCount * 0.2) * 2;
        fill(255); ellipse(-8, -25 + earShake, 10, 25); ellipse(8, -25 - earShake, 10, 25);
        fill(255, 200, 200); ellipse(-8, -22 + earShake, 5, 15); ellipse(8, -22 - earShake, 5, 15);
        fill(255); ellipse(0, 0, 40, 40);
        fill(255, 50, 50); ellipse(-10, -5, 6, 8); ellipse(10, -5, 6, 8);
        fill(255, 150, 150); triangle(0, 0, -3, -3, 3, -3);
        fill(255); ellipse(18, 12, 12, 12);
        pop();
    }
}

class StyrofoamTitan {
    constructor() {
        this.x = width/2; this.y = -200; this.targetY = 200;
        this.hp = 350; this.maxHp = 350;
        this.state = "entry"; // entry, normal, rage, ultimate
        this.timer = 0;
    }
    update() {
        this.timer++;
        let isRage = this.hp < this.maxHp / 2;
        
        // 1. 移動邏輯
        if (this.y < this.targetY) this.y += 3;
        let speedMult = isRage ? 2.5 : 1;
        this.x = width/2 + sin(frameCount * 0.02 * speedMult) * (width/3);

        // 2. 攻擊招式切換
        if (frameCount % (isRage ? 60 : 100) === 0) {
            // 隨機發動大招或散彈
            if (random() > 0.7) this.ultimate();
            else this.shotgunAttack();
        } else if (frameCount % 40 === 0) {
            // 普通狙擊彈
            bossBullets.push(new Bullet(this.x, this.y, atan2(player.y-this.y, player.x-this.x), true));
        }
    }
    shotgunAttack() {
        let baseA = atan2(player.y - this.y, player.x - this.x);
        for (let i = -2; i <= 2; i++) {
            bossBullets.push(new Bullet(this.x, this.y, baseA + i * 0.2, true));
        }
    }
    ultimate() {
        screenShake = 15;
        for (let a = 0; a < TWO_PI; a += PI/8) {
            bossBullets.push(new Bullet(this.x, this.y, a, true, 8)); // 快速的全方位彈
        }
    }
    display() {
        let isRage = this.hp < this.maxHp / 2;
        push(); translate(this.x, this.y); 
        if(isRage) tint(255, 100, 100); // 狂暴變紅
        rectMode(CENTER); noStroke();
        fill(200); rect(-80 + sin(frameCount*0.1)*10, 10, 50, 70, 5); 
        rect(80 + sin(frameCount*0.1 + PI)*10, 10, 50, 70, 5);
        fill(220); rect(-70, -20, 60, 60, 8); rect(70, -20, 60, 60, 8);
        fill(245); rect(0, 0, 110, 120, 15);
        if(isRage) { fill(255, 0, 0); ellipse(0, 0, 40, 40); } // 狂暴核心
        stroke(180); strokeWeight(2); line(-30, -30, -10, -10); line(20, 20, 40, 40);
        noStroke(); 
        fill(isRage ? color(255, 0, 0) : 20); // 狂暴紅眼
        ellipse(-25, -15, 35, 40); ellipse(25, -15, 35, 40);
        fill(255); ellipse(-20, -20, 10, 10); ellipse(30, -20, 10, 10);
        
        // 血條
        fill(50, 150); rect(0, -120, 200, 15);
        fill(isRage ? color(255, 0, 0) : color(255, 200, 0)); 
        rectMode(CORNER);
        rect(-100, -127, map(this.hp, 0, this.maxHp, 0, 200), 15);
        pop();
    }
}

class Bullet {
    constructor(x, y, a, isBoss = false, speed = 12) { 
        this.x = x; this.y = y; this.a = a; this.isBoss = isBoss; 
        this.speed = isBoss ? (speed * 0.6) : speed;
    }
    update() { this.x += cos(this.a)*this.speed; this.y += sin(this.a)*this.speed; }
    display() { 
        fill(this.isBoss?color(255, 255, 0):color(0, 255, 200)); 
        if(this.isBoss) {
            stroke(255, 100, 0); strokeWeight(2);
            ellipse(this.x, this.y, 25, 25);
        } else {
            noStroke(); ellipse(this.x, this.y, 10, 10);
        }
    }
}

function processGameLogic() {
    for (let i = bullets.length - 1; i >= 0; i--) {
        bullets[i].update(); bullets[i].display();
        let hit = false;
        if (boss && dist(bullets[i].x, bullets[i].y, boss.x, boss.y) < 70) { 
            boss.hp -= 5; hit = true; screenShake = 3;
        }
        for (let j = enemies.length - 1; j >= 0; j--) {
            if (dist(bullets[i].x, bullets[i].y, enemies[j].x, enemies[j].y) < 30) {
                enemies[j].hp--; if (enemies[j].hp <= 0) { deadQueue.push(enemies[j]); enemies.splice(j, 1); }
                hit = true; break;
            }
        }
        if (hit || bullets[i].y < 0 || bullets[i].x < 0 || bullets[i].x > width) bullets.splice(i, 1);
    }
    for (let e of enemies) {
        let a = atan2(player.y-e.y, player.x-e.x); e.x += cos(a)*2.2; e.y += sin(a)*2.2;
        imageMode(CENTER); image(imgs[e.imgIndex], e.x, e.y, 50, 50);
        if (dist(e.x, e.y, player.x, player.y) < 35) player.hp -= 0.5;
    }
    let pickedUpList = deadQueue.filter(e => e.isPickedUp);
    if (pickedUpList.length === 0) currentCarryType = -1;
    for (let i = 0; i < deadQueue.length; i++) {
        let e = deadQueue[i];
        if (!e.isPickedUp) {
            if (dist(player.x, player.y, e.x, e.y) < 50) {
                if (currentCarryType === -1 || e.imgIndex === currentCarryType) { e.isPickedUp = true; currentCarryType = e.imgIndex; }
            }
        } else {
            let targetX, targetY; let myOrder = pickedUpList.indexOf(e);
            if (myOrder === 0) { targetX = player.x; targetY = player.y + 45; }
            else { targetX = pickedUpList[myOrder-1].x; targetY = pickedUpList[myOrder-1].y + 35; }
            e.x = lerp(e.x, targetX, 0.2); e.y = lerp(e.y, targetY, 0.2);
        }
        push(); translate(e.x, e.y);
        if (e.isPickedUp) drawingContext.globalAlpha = 0.6;
        else if (currentCarryType !== -1 && e.imgIndex !== currentCarryType) { drawingContext.filter = 'grayscale(100%)'; drawingContext.globalAlpha = 0.3; }
        imageMode(CENTER); image(imgs[e.imgIndex], 0, 0, 50, 50); pop();
    }
    if (pickedUpList.length > 0) {
        let first = pickedUpList[0];
        for (let b of bins) {
            if (dist(first.x, first.y, b.x, b.y) < 90) {
                if (first.imgIndex === b.type) { score += 100; totalCleaned++; player.hp = min(100, player.hp + 10); }
                else { score -= 50; player.hp -= 20; screenShake = 10; }
                deadQueue.splice(deadQueue.indexOf(first), 1); break;
            }
        }
    }
    for (let i = bossBullets.length-1; i >= 0; i--) {
        bossBullets[i].update(); bossBullets[i].display();
        if (dist(bossBullets[i].x, bossBullets[i].y, player.x, player.y) < 25) { 
            player.hp -= 15; bossBullets.splice(i, 1); screenShake = 8;
        }
    }
    if (player.hp <= 0) gameOver = true;
}

class NightMarketMonster {
    constructor() { this.x = random(width); this.y = -50; this.hp = 2; this.imgIndex = floor(random(4)); this.isPickedUp = false; }
}

function handleInput() {
    let moveSpeed = 1.6;
    if (keyIsDown(LEFT_ARROW) || keyIsDown(65)) player.vx -= moveSpeed;
    if (keyIsDown(RIGHT_ARROW) || keyIsDown(68)) player.vx += moveSpeed;
    if (keyIsDown(UP_ARROW) || keyIsDown(87)) player.vy -= moveSpeed;
    if (keyIsDown(DOWN_ARROW) || keyIsDown(83)) player.vy += moveSpeed;
    if (mouseIsPressed && !leftJoy.active && !rightJoy.active && frameCount % 7 === 0) {
        let a = atan2(mouseY - player.y, mouseX - player.x); bullets.push(new Bullet(player.x, player.y, a));
    }
    if (leftJoy.active) {
        let a = atan2(leftJoy.currY - leftJoy.y, leftJoy.currX - leftJoy.x);
        let d = min(dist(leftJoy.x, leftJoy.y, leftJoy.currX, leftJoy.currY), joySize/2);
        player.vx += cos(a) * (d/(joySize/2)) * 1.8; player.vy += sin(a) * (d/(joySize/2)) * 1.8;
    }
    if (rightJoy.active && frameCount % 7 === 0) {
        let a = atan2(rightJoy.currY - rightJoy.y, rightJoy.currX - rightJoy.x); bullets.push(new Bullet(player.x, player.y, a));
    }
}

function drawUI() {
    fill(255); textAlign(LEFT); textSize(18); text(`小白兔能源: ${floor(player.hp)}%`, 20, 30); text(`回收進度: ${totalCleaned} / ${TARGET_CLEANED}`, 20, 60);
    fill(255, 255, 0); textSize(14); 
    if (boss) { fill(255, 0, 0); text("警告：檢測到大型保麗龍反應！", 20, 90); }
    else { text(currentCarryType === -1 ? "提示：清掉小怪後撿起垃圾分類" : "正在回收：" + ["塑膠袋", "紙杯", "玻璃瓶", "寶特瓶"][currentCarryType], 20, 90); }
}

function touchStarted() {
    for (let t of touches) {
        if (t.x < width/2 && !leftJoy.active) { leftJoy.active = true; leftJoy.id = t.id; leftJoy.x = t.x; leftJoy.y = t.y; leftJoy.currX = t.x; leftJoy.currY = t.y; }
        else if (t.x >= width/2 && !rightJoy.active) { rightJoy.active = true; rightJoy.id = t.id; rightJoy.x = t.x; rightJoy.y = t.y; rightJoy.currX = t.x; rightJoy.currY = t.y; }
    }
    if (gameOver) location.reload();
    return false;
}
function touchMoved() {
    for (let t of touches) { if (t.id === leftJoy.id) { leftJoy.currX = t.x; leftJoy.currY = t.y; } if (t.id === rightJoy.id) { rightJoy.currX = t.x; rightJoy.currY = t.y; } }
    return false;
}
function touchEnded() {
    let sL = false, sR = false; for (let t of touches) { if (t.id === leftJoy.id) sL = true; if (t.id === rightJoy.id) sR = true; }
    if (!sL) leftJoy.active = false; if (!sR) rightJoy.active = false; return false;
}
function drawJoystick(joy, col) {
    if (joy.active) {
        fill(col); noStroke(); ellipse(joy.x, joy.y, joySize);
        let a = atan2(joy.currY - joy.y, joy.currX - joy.x);
        let d = min(dist(joy.x, joy.y, joy.currX, joy.currY), joySize/2);
        fill(255, 150); ellipse(joy.x + cos(a)*d, joy.y + sin(a)*d, 60);
    }
}
function mousePressed() { if (gameOver) location.reload(); }
</script>
</body>
</html>
