<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style> body { margin: 0; overflow: hidden; background: #000; touch-action: none; } </style>
</head>
<body>
<script>
let player, bullets = [], enemies = [], bossBullets = [], fragments = [], boss;
let imgs = [];
let gameTimer = 0, gameOver = false, score = 0;
let totalCleaned = 0, TARGET_CLEANED = 15; // 設定清理 15 隻小怪後 Boss 出現
let bins = [];
let leftJoy = { active: false, id: -1, x: 0, y: 0, currX: 0, currY: 0 };
let rightJoy = { active: false, id: -1, x: 0, y: 0, currX: 0, currY: 0 };
let joySize = 130;

function preload() {
    imgs[0] = loadImage('怪物1號.png'); // 黃
    imgs[1] = loadImage('怪物二號.png'); // 紅
    imgs[2] = loadImage('怪物三號.png'); // 綠
    imgs[3] = loadImage('怪物四號.png'); // 藍
}

function setup() { 
    createCanvas(windowWidth, windowHeight); 
    player = new Player(); 
    let binLabels = ["塑膠袋", "紙杯", "玻璃瓶", "寶特瓶"];
    let binColors = [color(255, 220, 0), color(255, 50, 50), color(50, 200, 50), color(0, 100, 255)];
    let spacing = width / 4;
    for(let i=0; i<4; i++) {
        bins.push({ x: spacing*i + spacing/2, y: height-60, w: 75, h: 95, type: i, col: binColors[i], label: binLabels[i] });
    }
}

function draw() {
    if (gameOver) {
        background(0, 180); fill(255, 50, 50); textAlign(CENTER); textSize(40);
        text("守護失敗！", width/2, height/2);
        textSize(20); fill(255); text("點擊畫面重新開始", width/2, height/2 + 50);
        return;
    }
    background(20, 25, 35);
    handleInput();

    // 繪製垃圾桶
    rectMode(CENTER);
    for (let b of bins) {
        fill(b.col); stroke(255); strokeWeight(2);
        rect(b.x, b.y, b.w, b.h, 8);
        fill(255); noStroke(); textAlign(CENTER); textSize(14);
        text(b.label, b.x, b.y + 10);
    }

    player.update(); player.display();

    // 遊戲階段邏輯
    if (totalCleaned < TARGET_CLEANED) {
        if (frameCount % 80 === 0 && enemies.length < 10) enemies.push(new NightMarketMonster());
    } else if (!boss) {
        boss = new StyrofoamTitan();
        enemies = []; // 清除剩餘小怪迎接 Boss
    }

    if (boss) {
        boss.update(); boss.display();
        if (boss.hp <= 0) {
            noLoop(); background(0, 200); fill(0, 255, 100); textAlign(CENTER); textSize(35);
            text("成功淨化保麗龍泰坦！", width/2, height/2);
        }
    }

    handleCombatAndQueueSorting();
    drawUI();
    drawJoystick(leftJoy, color(0, 200, 255, 80));
    drawJoystick(rightJoy, color(255, 50, 50, 80));
}

class Player {
    constructor() { this.x = width/2; this.y = height*0.6; this.vx = 0; this.vy = 0; this.hp = 100; }
    update() {
        this.vx *= 0.88; this.vy *= 0.88;
        this.x += this.vx; this.y += this.vy;
        this.x = constrain(this.x, 20, width-20);
        this.y = constrain(this.y, 20, height-150);
    }
    display() {
        push(); translate(this.x, this.y);
        fill(0, 150, 255); stroke(255); rect(0, 0, 35, 35, 5);
        fill(255); noStroke(); ellipse(0, -5, 12, 8);
        pop();
    }
}

class NightMarketMonster {
    constructor() {
        this.x = random(width); this.y = -50;
        this.hp = 2; this.imgIndex = floor(random(4));
        this.isDead = false; this.dragIndex = -1; // 排隊序號
    }
update() {
        if (!this.isDead) {
            // 活著的時候：追逐玩家
            let a = atan2(player.y - this.y, player.x - this.x);
            this.x += cos(a) * 2.5; 
            this.y += sin(a) * 2.5;
        } else {
            // 死了以後：只跟隨「已經在隊伍中」的遺體
            // 我們只篩選出已經死亡的怪物來排隊
            let deadQueue = enemies.filter(e => e.isDead);
            let myIndex = deadQueue.indexOf(this);

            let targetX, targetY;
            if (myIndex === 0) {
                // 第一個遺體：跟隨玩家
                targetX = player.x;
                targetY = player.y + 45;
            } else {
                // 後面的遺體：只跟隨前一個「遺體」
                let leader = deadQueue[myIndex - 1];
                targetX = leader.x;
                targetY = leader.y + 35;
            }

            // 平滑移動到隊伍位置
            this.x = lerp(this.x, targetX, 0.2);
            this.y = lerp(this.y, targetY, 0.2);
        }
    }
    }
    display() {
        push(); translate(this.x, this.y);
        if (this.isDead) drawingContext.globalAlpha = 0.5;
        imageMode(CENTER); image(imgs[this.imgIndex], 0, 0, 50, 50);
        pop();
    }
}

class StyrofoamTitan {
    constructor() {
        this.x = width/2; this.y = -100; this.targetY = 150;
        this.hp = 250; this.maxHp = 250;
    }
    update() {
        if (this.y < this.targetY) this.y += 2;
        this.x = width/2 + sin(frameCount*0.02)*120;
        if (frameCount % 50 === 0) bossBullets.push(new Bullet(this.x, this.y, atan2(player.y-this.y, player.x-this.x), true));
    }
    display() {
        push(); translate(this.x, this.y);
        fill(245); stroke(200); rect(0, 0, 120, 100, 10);
        fill(255, 50, 50); ellipse(0, 0, 40, 30);
        pop();
    }
}

function handleCombatAndQueueSorting() {
    // 處理子彈
    for (let i = bullets.length-1; i >= 0; i--) {
        bullets[i].update(); bullets[i].display();
        if (boss && dist(bullets[i].x, bullets[i].y, boss.x, boss.y) < 60) {
            boss.hp -= 5; bullets.splice(i, 1); continue;
        }
        for (let e of enemies) {
            if (!e.isDead && dist(bullets[i].x, bullets[i].y, e.x, e.y) < 30) {
                e.hp--; bullets.splice(i, 1); break;
            }
        }
    }

    // 處理分類 (排隊進桶)
    let deadEnemies = enemies.filter(e => e.isDead);
    if (deadEnemies.length > 0) {
        let firstInLine = deadEnemies[0]; // 永遠只有隊伍第一隻會被判定進桶
        for (let b of bins) {
            if (dist(firstInLine.x, firstInLine.y, b.x, b.y) < 80) {
                if (firstInLine.imgIndex === b.type) {
                    score += 100; totalCleaned++; player.hp = min(100, player.hp + 8);
                } else {
                    score -= 50; player.hp -= 15;
                }
                enemies.splice(enemies.indexOf(firstInLine), 1);
                break;
            }
        }
    }

    // 更新怪物狀態
    for (let i = enemies.length - 1; i >= 0; i--) {
        enemies[i].update(); enemies[i].display();
        if (!enemies[i].isDead && enemies[i].hp <= 0) enemies[i].isDead = true;
        if (!enemies[i].isDead && dist(enemies[i].x, enemies[i].y, player.x, player.y) < 35) player.hp -= 0.3;
    }
    
    // Boss 子彈
    for (let i = bossBullets.length-1; i >= 0; i--) {
        bossBullets[i].update(); bossBullets[i].display();
        if (dist(bossBullets[i].x, bossBullets[i].y, player.x, player.y) < 25) {
            player.hp -= 10; bossBullets.splice(i, 1);
        }
    }
    if (player.hp <= 0) gameOver = true;
}

class Bullet {
    constructor(x, y, a, isBoss = false) { this.x = x; this.y = y; this.a = a; this.isBoss = isBoss; }
    update() { this.x += cos(this.a)*(this.isBoss?6:12); this.y += sin(this.a)*(this.isBoss?6:12); }
    display() { 
        fill(this.isBoss?color(255, 255, 0):color(0, 255, 200)); 
        noStroke(); ellipse(this.x, this.y, this.isBoss?20:10, this.isBoss?20:10); 
    }
}

function drawUI() {
    fill(255); textAlign(LEFT); textSize(18);
    text(`機器人能源: ${floor(player.hp)}%`, 20, 30);
    text(`淨化進度: ${totalCleaned} / ${TARGET_CLEANED}`, 20, 60);
    if (totalCleaned < TARGET_CLEANED) {
        fill(0, 255, 255); textSize(14);
        text("清理小怪以引出保麗龍泰坦", 20, 90);
    } else if (boss) {
        fill(255, 50, 50); text(`BOSS HP: ${floor(boss.hp)}`, 20, 90);
    }
}

// 搖桿控制部分 (略，同之前代碼)
function touchStarted() {
    for (let t of touches) {
        if (t.x < width/2 && !leftJoy.active) { leftJoy.active = true; leftJoy.id = t.id; leftJoy.x = t.x; leftJoy.y = t.y; leftJoy.currX = t.x; leftJoy.currY = t.y; }
        else if (t.x >= width/2 && !rightJoy.active) { rightJoy.active = true; rightJoy.id = t.id; rightJoy.x = t.x; rightJoy.y = t.y; rightJoy.currX = t.x; rightJoy.currY = t.y; }
    }
    if (gameOver) location.reload();
    return false;
}
function touchMoved() {
    for (let t of touches) {
        if (t.id === leftJoy.id) { leftJoy.currX = t.x; leftJoy.currY = t.y; }
        if (t.id === rightJoy.id) { rightJoy.currX = t.x; rightJoy.currY = t.y; }
    }
    return false;
}
function touchEnded() {
    let sL = false, sR = false;
    for (let t of touches) { if (t.id === leftJoy.id) sL = true; if (t.id === rightJoy.id) sR = true; }
    if (!sL) leftJoy.active = false; if (!sR) rightJoy.active = false;
    return false;
}
function handleInput() {
    if (leftJoy.active) {
        let a = atan2(leftJoy.currY - leftJoy.y, leftJoy.currX - leftJoy.x);
        let d = min(dist(leftJoy.x, leftJoy.y, leftJoy.currX, leftJoy.currY), joySize/2);
        player.vx += cos(a) * (d/(joySize/2)) * 1.5;
        player.vy += sin(a) * (d/(joySize/2)) * 1.5;
    }
    if (rightJoy.active && frameCount % 8 === 0) {
        let a = atan2(rightJoy.currY - rightJoy.y, rightJoy.currX - rightJoy.x);
        bullets.push(new Bullet(player.x, player.y, a));
    }
}
function drawJoystick(joy, col) {
    if (joy.active) {
        fill(col); noStroke(); ellipse(joy.x, joy.y, joySize);
        let a = atan2(joy.currY - joy.y, joy.currX - joy.x);
        let d = min(dist(joy.x, joy.y, joy.currX, joy.currY), joySize/2);
        fill(255, 150); ellipse(joy.x + cos(a)*d, joy.y + sin(a)*d, 60);
    }
}
function handleCombatAndQueueSorting() {
    // ... 前方的子彈判定代碼保持不變 ...

    // 取得目前的遺體隊伍
    let deadQueue = enemies.filter(e => e.isDead);
    
    if (deadQueue.length > 0) {
        // 只有隊伍的第一隻 (最靠近玩家的) 會被垃圾桶吸進去
        let firstTrash = deadQueue[0]; 
        
        for (let b of bins) {
            // 增加判定距離到 90，讓玩家拖過去時更感應靈敏
            if (dist(firstTrash.x, firstTrash.y, b.x, b.y) < 90) {
                if (firstTrash.imgIndex === b.type) {
                    score += 100; 
                    totalCleaned++; 
                    player.hp = min(100, player.hp + 8);
                } else {
                    score -= 50; 
                    player.hp -= 15;
                }
                // 從總怪獸陣列中移除這隻已分類的怪
                let idx = enemies.indexOf(firstTrash);
                enemies.splice(idx, 1);
                break; 
            }
        }
    }
    // ... 後續的 Boss 與碰撞代碼保持不變 ...
}
</script>
</body>
</html>
